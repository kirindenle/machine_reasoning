import string;
import ds/list;
import ds/array;
import lingo/pegcode/driver;

grammar = compilePegGrammar("#include predicates.lingo");

PredTerm ::= PredVar, PredFunc;
    PredVar(x: string);
    PredFunc(name: string, args: [PredTerm]);

Form ::= FormAtom, FormAll, FormEx, FormAnd, FormOr, FormNot;
    FormAtom(name: string, args: [PredTerm]);
    FormAll(var: string, p: Form);
    FormEx(var: string, p: Form);
    FormAnd(lhs: Form, rhs: Form);
    FormOr(lhs: Form, rhs: Form);
    FormNot(p: Form);


NNF ::= NNFLiteral, NNFAll, NNFEx, NNFAnd, NNFOr;
    NNFLiteral(sign: bool, name: string, args: [PredTerm]);
    NNFAll(var: string, p: NNF);
    NNFEx(var: string, p: NNF);
    NNFAnd(lhs: NNF, rhs: NNF);
    NNFOr(lhs: NNF, rhs: NNF);


toNNF(phi: Form) -> NNF {
    switch(phi) {
        FormNot(psi): {
            switch(psi) {
                FormNot(p): {
                    toNNF(p);
                }
                FormAtom(name, args): {
                    NNFLiteral(false, name, args);
                }
                FormAll(var, p): {
                    NNFEx(var, toNNF(FormNot(p)));
                }
                FormEx(var, p): {
                    NNFAll(var, toNNF(FormNot(p)));
                }
                FormAnd(lhs, rhs): {
                    NNFOr(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
                FormOr(lhs, rhs): {
                    NNFAnd(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
            }
        }
        FormAtom(name, args): {
            NNFLiteral(true, name, args);
        }
        FormAll(var, p): {
            NNFAll(var, toNNF(p));
        }
        FormEx(var, p): {
            NNFEx(var, toNNF(p));
        }
        FormAnd(lhs, rhs): {
            NNFAnd(toNNF(lhs), toNNF(rhs));
        }
        FormOr(lhs, rhs): {
            NNFOr(toNNF(lhs), toNNF(rhs));
        }
    }
}



PredTerm2string(t: PredTerm) -> string {
    switch(t) {
        PredVar(x): 
            x;
        PredFunc(f, as): 
            f + "(" + strGlue(map(as, PredTerm2string), ", ") + ")";
    }
}

Form2string(phi : Form) -> string {
    switch(phi) {
        FormAtom(p, as): {
            p + "(" + strGlue(map(as, PredTerm2string), ", ") + ")";
        }
        FormAll(var, p): {
            "A" + var + " " + Form2string(p);
        }
        FormEx(var, p): {
            "E" + var + " " + Form2string(p);
        }
        FormAnd(lhs, rhs): {
            "(" + Form2string(lhs) + " & " + Form2string(rhs) + ")";
        }
        FormOr(lhs, rhs): {
            "(" + Form2string(lhs) + " | " + Form2string(rhs) + ")";
        }
        FormNot(p): {
            "!" + Form2string(p);
        }
    }
}


/*

standartizeNNF_helper(psi: NNF, renamings: ref Tree<string, string>) -> NNF {
    switch(psi) {
        NNFLiteral(s, n, as): NNFLiteral(!s, n, as);
        NNFAll(x, p): NNFAll(x, standartizeNNF_helper(p, renamings));
        NNFEx(x, p): NNFEx(x, standartizeNNF_helper(p, renamings));
        NNFAnd(l, r): NNFAnd(standartizeNNF_helper(l, renamings), standartizeNNF_helper(r, renamings));
        NNFOr(l, r): NNFOr(standartizeNNF_helper(l, renamings), standartizeNNF_helper(r, renamings));
    }
}

standartizeNNF(phi: NNF) -> Pair<NNF, Tree<string, string>> {
    renamings : ref Tree<string, string> = ref TreeEmpty();
    Pair(standartizeNNF_helper(phi, renamings), ^renamings);
}*/


main() {
    s = "Ax (less(plus(x, y), y) -> more(y, x))";
    s2 = "Ay P()";
    e = parsic(grammar, s, defaultPegActions);
    println(Form2string(e));
    println("");
    // println(toNNF(e));
    e2 = parsic(grammar, s2, defaultPegActions);
    println(e2);
}