import string;
import ds/list;
import ds/array;
import lingo/pegcode/driver;

grammar = compilePegGrammar("#include predicates.lingo");

PredTerm ::= PredVar, PredFunc;
    PredVar(x: string);
    PredFunc(name: string, args: [PredTerm]);

Form ::= FormAtom, FormAll, FormEx, FormAnd, FormOr, FormNot;
    FormAtom(name: string, args: [PredTerm]);
    FormAll(var: string, p: Form);
    FormEx(var: string, p: Form);
    FormAnd(lhs: Form, rhs: Form);
    FormOr(lhs: Form, rhs: Form);
    FormNot(p: Form);


NNF ::= NNFLiteral, NNFAll, NNFEx, NNFAnd, NNFOr;
    NNFLiteral(sign: bool, name: string, args: [PredTerm]);
    NNFAll(var: string, p: NNF);
    NNFEx(var: string, p: NNF);
    NNFAnd(lhs: NNF, rhs: NNF);
    NNFOr(lhs: NNF, rhs: NNF);

/*
toNNF(phi: Form) -> NNF {
    predlist2predarray = \args -> reverseA(list2array(mapList(args, \p -> switch(p) {
        PredFuncList(f, as): PredFunc(f, reverseA(list2array(as)));
        PredVarList(x): PredVar(x);
    })));
    switch(phi) {
        FormNot(psi): {
            switch(psi) {
                FormNot(p): {
                    toNNF(p);
                }
                FormAtom(name, args): {
                    NNFLiteral(false, name, predlist2predarray(args));
                }
                FormAll(var, p): {
                    NNFEx(var, toNNF(FormNot(p)));
                }
                FormEx(var, p): {
                    NNFAll(var, toNNF(FormNot(p)));
                }
                FormAnd(lhs, rhs): {
                    NNFOr(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
                FormOr(lhs, rhs): {
                    NNFAnd(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
            }
        }
        FormAtom(name, args): {
            NNFLiteral(true, name, predlist2predarray(args));
        }
        FormAll(var, p): {
            NNFAll(var, toNNF(p));
        }
        FormEx(var, p): {
            NNFEx(var, toNNF(p));
        }
        FormAnd(lhs, rhs): {
            NNFAnd(toNNF(lhs), toNNF(rhs));
        }
        FormOr(lhs, rhs): {
            NNFOr(toNNF(lhs), toNNF(rhs));
        }
    }
}
*/
/*

standartizeNNF_helper(psi: NNF, renamings: ref Tree<string, string>) -> NNF {
    switch(psi) {
        NNFLiteral(s, n, as): NNFLiteral(!s, n, as);
        NNFAll(x, p): NNFAll(x, standartizeNNF_helper(p, renamings));
        NNFEx(x, p): NNFEx(x, standartizeNNF_helper(p, renamings));
        NNFAnd(l, r): NNFAnd(standartizeNNF_helper(l, renamings), standartizeNNF_helper(r, renamings));
        NNFOr(l, r): NNFOr(standartizeNNF_helper(l, renamings), standartizeNNF_helper(r, renamings));
    }
}

standartizeNNF(phi: NNF) -> Pair<NNF, Tree<string, string>> {
    renamings : ref Tree<string, string> = ref TreeEmpty();
    Pair(standartizeNNF_helper(phi, renamings), ^renamings);
}*/


main() {
    s = "less(x,)";
    s2 = "Ay P()";
    e = parsic(grammar, s, defaultPegActions);
    println(e);
    println("");
    // println(toNNF(e));
    e2 = parsic(grammar, s2, defaultPegActions);
    println(e2);
}