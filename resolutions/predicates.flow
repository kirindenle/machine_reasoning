import string;
import ds/list;
import ds/set;
import ds/array;
import lingo/pegcode/driver;

grammar = compilePegGrammar("#include predicates.lingo");

PredTerm ::= PredVar, PredFunc;
    PredVar(x: string);
    PredFunc(name: string, args: [PredTerm]);

Atom(name: string, args: [PredTerm]);

Form ::= Atom, FormAll, FormEx, FormAnd, FormOr, FormNot;
    FormAll(var: string, p: Form);
    FormEx(var: string, p: Form);
    FormAnd(lhs: Form, rhs: Form);
    FormOr(lhs: Form, rhs: Form);
    FormNot(p: Form);


Literal(sign: bool, p: Atom);

NNF ::= Literal, NNFAll, NNFEx, NNFAnd, NNFOr;
    NNFAll(var: string, p: NNF);
    NNFEx(var: string, p: NNF);
    NNFAnd(lhs: NNF, rhs: NNF);
    NNFOr(lhs: NNF, rhs: NNF);


toNNF(phi: Form) -> NNF {
    switch(phi) {
        FormNot(psi): {
            switch(psi) {
                FormNot(p): {
                    toNNF(p);
                }
                Atom(name, args): {
                    Literal(false, psi);
                }
                FormAll(var, p): {
                    NNFEx(var, toNNF(FormNot(p)));
                }
                FormEx(var, p): {
                    NNFAll(var, toNNF(FormNot(p)));
                }
                FormAnd(lhs, rhs): {
                    NNFOr(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
                FormOr(lhs, rhs): {
                    NNFAnd(toNNF(FormNot(lhs)), toNNF(FormNot(rhs)));
                }
            }
        }
        Atom(name, args): {
            Literal(true, phi);
        }
        FormAll(var, p): {
            NNFAll(var, toNNF(p));
        }
        FormEx(var, p): {
            NNFEx(var, toNNF(p));
        }
        FormAnd(lhs, rhs): {
            NNFAnd(toNNF(lhs), toNNF(rhs));
        }
        FormOr(lhs, rhs): {
            NNFOr(toNNF(lhs), toNNF(rhs));
        }
    }
}

PredTerm2string(t: PredTerm) -> string {
    switch(t) {
        PredVar(x): x;
        PredFunc(f, as): f + "(" + strGlue(map(as, PredTerm2string), ", ") + ")";
    }
}

Form2string(phi : Form) -> string {
    switch(phi) {
        Atom(p, as): p + "(" + strGlue(map(as, PredTerm2string), ", ") + ")";
        FormAll(var, p): "A" + var + " " + Form2string(p);
        FormEx(var, p): "E" + var + " " + Form2string(p);
        FormAnd(lhs, rhs): "(" + Form2string(lhs) + " & " + Form2string(rhs) + ")";
        FormOr(lhs, rhs): "(" + Form2string(lhs) + " | " + Form2string(rhs) + ")";
        FormNot(p): "!" + Form2string(p);
    }
}

Literal2string(l: Literal) -> string {
    (if (l.sign) "" else "!") + l.p.name + "(" + strGlue(map(l.p.args, PredTerm2string), ", ") + ")";
}

NNF2string(phi : NNF) -> string {
    switch(phi) {
        Literal(s, p): Literal2string(phi);
        NNFAll(var, p): "A" + var + " " + NNF2string(p);
        NNFEx(var, p): "E" + var + " " + NNF2string(p);
        NNFAnd(lhs, rhs): "(" + NNF2string(lhs) + " & " + NNF2string(rhs) + ")";
        NNFOr(lhs, rhs): "(" + NNF2string(lhs) + " | " + NNF2string(rhs) + ")";
    }
}

substPredTerm(pt: PredTerm, v: string, new_term: PredTerm) {
    switch(pt) {
        PredVar(x): if (x == v) new_term else pt;
        PredFunc(f, as): PredFunc(f, map(as, \t -> substPredTerm(t, v, new_term)));
    }
}

substNNF(psi: NNF, v: string, new_name: string) {
    switch(psi) {
        Literal(s, p): Literal(s, Atom(p.name, map(p.args, \t -> substPredTerm(t, v, PredVar(new_name)))));
        NNFAll(x, p): if (x == v) psi else NNFAll(x, substNNF(p, v, new_name));
        NNFEx(x, p): if (x == v) psi else NNFEx(x, substNNF(p, v, new_name));
        NNFAnd(l, r): NNFAnd(substNNF(l, v, new_name), substNNF(r, v, new_name));
        NNFOr(l, r): NNFOr(substNNF(l, v, new_name), substNNF(r, v, new_name));
    }
}

var_names_helper = ref 0;
standartizeNNFhelper(psi: NNF) -> NNF {
    switch(psi) {
        NNFAll(x, p): {
            new_name = "_x" + i2s(^var_names_helper);
            var_names_helper := ^var_names_helper + 1;
            NNFAll(new_name, standartizeNNFhelper(substNNF(p, x, new_name)));
        }
        NNFEx(x, p): {
            new_name = "_x" + i2s(^var_names_helper);
            var_names_helper := ^var_names_helper + 1;
            NNFEx(new_name, standartizeNNFhelper(substNNF(p, x, new_name)));
        }
        Literal(s, p): psi;
        NNFAnd(l, r): NNFAnd(standartizeNNFhelper(l), standartizeNNFhelper(r));
        NNFOr(l, r): NNFOr(standartizeNNFhelper(l), standartizeNNFhelper(r));
    }
}

standartizeNNF(psi: NNF) -> NNF {
    var_names_helper := 0;
    res = standartizeNNFhelper(psi);
    var_names_helper := 0;
    res;
}

Quantifier ::= All, Exists;
    All();
    Exists();

QVar(q: Quantifier, x: string);

PrenexForm(qs: [QVar], p: NonQForm);
NonQForm ::= Literal, NonQAnd, NonQOr;
    NonQAnd(lhs: NonQForm, rhs: NonQForm);
    NonQOr(lhs: NonQForm, rhs: NonQForm);

NonQForm2string(nqf: NonQForm) -> string {
    switch(nqf) {
        Literal(s, p): Literal2string(nqf);
        NonQAnd(l, r): "(" + NonQForm2string(l) + " & " + NonQForm2string(r) + ")";
        NonQOr(l, r): "(" + NonQForm2string(l) + " | " + NonQForm2string(r) + ")";
    }
}

PF2string(pf : PrenexForm) -> string {
    Qstr = strGlue(map(pf.qs, \qv -> switch(qv.q) {
        All(): "A";
        Exists(): "E";
    } + qv.x), " ");
    Qstr + " " + NonQForm2string(pf.p);
}

shiftAE(psi: NNF) -> PrenexForm {
    switch(psi) {
        NNFAll(x, p): {
            pf = shiftAE(p);
            PrenexForm(concat([QVar(All(), x)], pf.qs), pf.p);
        }
        NNFEx(x, p): {
            pf = shiftAE(p);
            PrenexForm(concat([QVar(Exists(), x)], pf.qs), pf.p);
        }
        NNFAnd(l, r): {
            pfl = shiftAE(l);
            pfr = shiftAE(r);
            PrenexForm(concat(pfl.qs, pfr.qs), NonQAnd(pfl.p, pfr.p));
        }
        NNFOr(l, r): {
            pfl = shiftAE(l);
            pfr = shiftAE(r);
            PrenexForm(concat(pfl.qs, pfr.qs), NonQOr(pfl.p, pfr.p));
        }
        Literal(s, p): PrenexForm([], psi);
    }
}

// CNF = [Tree<Atom, bool>]


hasCancellingLiterals(l: Tree<Atom, bool>, r: Tree<Atom, bool>) -> bool {
    foldTree(l, false, 
    \atom, sign_left, acc -> {
        if (acc) true else switch (lookupTree(r, atom)) {
            Some(sign_right): sign_right != sign_left;
            None(): acc;
        }
    });
}

CNFEntry2string(dis: Tree<Atom, bool>) -> string {
    arr = convertTreeToArray(dis, \a, s -> Literal2string(Literal(s, a)));
    if (length(arr) == 1) {
        arr[0];
    } else {
        "(" + strGlue(arr, " | ") + ")";
    }
}

CNF2string(cnf: [Tree<Atom, bool>]) -> string {
    strGlue(map(cnf, CNFEntry2string), " & ");
}

NonQForm2CNF(nqf: NonQForm) -> [Tree<Atom, bool>] {
    switch(nqf) {
        NonQAnd(lhs, rhs): {
            concat(NonQForm2CNF(lhs), NonQForm2CNF(rhs));
        }
        NonQOr(lhs, rhs): {
            left = NonQForm2CNF(lhs);
            right = NonQForm2CNF(rhs);
            mapConcat(left, \left_tree -> {
                filtermap(right, \right_tree -> {
                    if (hasCancellingLiterals(left_tree, right_tree)) {
                        None();
                    } else {
                        Some(mergeTree(left_tree, right_tree));
                    }
                })
            })
        }
        Literal(s, a): [makeTree1(a, s)];
    }
}

PrenexNormalForm(qs: [QVar], p: [Tree<Atom, bool>]);

PNF2string(pnf: PrenexNormalForm) -> string {
    Qstr = strGlue(map(pnf.qs, \qv -> switch(qv.q) {
        All(): "A";
        Exists(): "E";
    } + qv.x), " ");
    Qstr + " " + CNF2string(pnf.p);
}

PF2PNF(pf: PrenexForm) -> PrenexNormalForm {
    PrenexNormalForm(pf.qs, NonQForm2CNF(pf.p));
}

Form2PNF(f: Form) -> PrenexNormalForm {
    PF2PNF(shiftAE(standartizeNNF(toNNF(f))));
}

SkolemNormalForm(As: [string], p: [Tree<Atom, bool>]);

substPred2Atom(a: Atom, x: string, new_term: PredTerm) {
    Atom(a.name, map(a.args, \pt -> substPredTerm(pt, x, new_term)));
}

substPred2Dis(dis: Tree<Atom, bool>, x: string, new_term: PredTerm) -> Tree<Atom, bool> {
    foldTree(dis, TreeEmpty(), \a, s, acc -> {
        setTree(acc, substPred2Atom(a, x, new_term), s);
    });
}

strings2Func(ss: [string], fun_names_helper: ref int) -> PredFunc {
    f = "_f" + i2s(^fun_names_helper);
    fun_names_helper := ^fun_names_helper + 1;
    PredFunc(f, map(ss, \s -> PredVar(s)));
}

PNF2SNF(pnf: PrenexNormalForm) -> SkolemNormalForm {
    fun_names_helper = ref -1;
    fold(pnf.qs, SkolemNormalForm([], pnf.p), \acc, qv -> {
        switch(qv.q) {
            All(): SkolemNormalForm(arrayPush(acc.As, qv.x), acc.p);
            Exists(): {
                fun_names_helper := ^fun_names_helper + 1;
                SkolemNormalForm(acc.As, map(acc.p, \dis -> 
                    substPred2Dis(dis, qv.x, 
                        PredFunc("_f" + i2s(^fun_names_helper), 
                            map(acc.As, \s -> PredVar(s))))));
            }
        }
    });
}

SNF2string(snf: SkolemNormalForm) -> string {
    "A" + strGlue(snf.As, ", ") + ": " + CNF2string(snf.p);
}


main() {
    s = "Ex (P(x) & (Ay Q(y) & Az R(z)))";
    e = parsic(grammar, s, defaultPegActions);
    estand = standartizeNNF(toNNF(e));
    println(Form2string(e));
    println(NNF2string(estand));
    println(PF2string(shiftAE(estand)));
    println(SNF2string(PNF2SNF(Form2PNF(e))));
    // println(toNNF(e));
}